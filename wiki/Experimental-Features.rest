Configurable authentication/authorization methods
-------------------------------------------------
The same user can get a token for access restricted for different scopes. It is configured in the control panel and selected by client_id (CONSUMER_KEY in this package). The necessary selected scopes are "api" or "full". There is currently no known difference between these scopes for django-salesforce, only by the user and all authorization is done on the Salesforce side. Therefore the term "authorization" is used here and "authentication" would be also correct.

Username and Password (default method)
......................................
``salesforcce.auth.SalesforcePasswordAuth`` It is described in README.
The original use-case for django-salesforce assumed use of a single set of credentials with read-write access to all necessary objects. It requires the necessary CONSUMER_KEY and CONSUMER_SECRET and frequently also the security token appended to the PASSWORD.

Authentication by a token from Force.com CLI
............................................
``salesforcce.auth.ForceComCliAuth`` The open source command-line development tool `Force.com CLI <http://force-cli.herokuapp.com/>`__ is very useful e.g. for extending the database schema. It also saves the access tokens to the user profile. These tokens expire after two hours of inactivity or after a shorter expiration time configured in the control panel. This is much better than to save a huge amount of passwords and other security sensitive information if more sandboxes and production instances are temporarily used with different user profiles. It is unpleasant, if the passwords are not deleted before a backup or if an obsoleted password or security token is left in settings in some virtual environment and it has caused a locked account temporarily, if a strict password policy is configured in the control panel. The administrator profile access is usually necessary only for a short time. Example of database settings::

 'salesforce': {
     'ENGINE': 'salesforce.backend',
     'AUTH': 'salesforce.auth.ForceComCliAuth',
     'USER': 'me@email.example.com',
 }


Dynamic authorization
.....................
It's now possible to write applications that use OAuth to interact with a Salesforce
instance's data on your end user's behalf. You simply need to know or request the
`Access Token <https://www.salesforce.com/us/developer/docs/api_rest/Content/quickstart_oauth.htm>`__
for the user in question and you can start and terminate the dynamic authorization. 
It can be combined with any type of static authentication, that is valid before the start and after the end of dynamic authentication this way, probably by
creating a Django middleware component. Then at the beginning of each request::

   from django.db import connections
   # After you get the access token for the user in some way
   # authenticate to SFDC with
   connections['salesforce'].sf_session.auth.dynamic_start(access_token)

   # or to override the `instance_url` on a per-request basis
   connections['salesforce'].sf_session.auth.dynamic_start(access_token, instance_url)

Make sure to purge the access token at end of request::

   connections['salesforce'].sf_session.auth.dynamic_end()


In this situation, if you don't need a static authorization at all, you can use only the
``DynamicAuth`` replacement instead and to configure your ``DATABASES`` setting as follows::

 'salesforce': {
     'ENGINE': 'salesforce.backend',
     'AUTH': 'salesforce.auth.DynamicAuth',
     # optional if "instance_url" is a part of "dynamic_start" call
     'HOST': 'https://your-site.salesforce.com',
 }

A static SFDC connection can be specified with the data server URL in "HOST"
Note that in this case we're not using the URL of the login server â€” the data
server URL can be also used for login.

An example is `Canvas Signed Request Authentication <https://developer.salesforce.com/docs/atlas.en-us.platform_connect.meta/platform_connect/canvas_app_signed_req_authentication.htm>`__ that is out of this scope. That allows to insert a frame related to the object displayed or edited on Salesforce web instance, restricted by permissions of the current user.

Customized Auth
...............
Many auth classes are so simple that they can be easily extended by inheritance. Only ``authenticate()`` method, ``required_fields`` attribute and maybe ``can_reauthenticate=True`` need to be modified.


Django-Admin Support
--------------------
If you use multiple Salesforce databases or multiple instances of AdminSite, you'll
probably want to extend ``salesforce.admin.RoutedModelAdmin``" in your admin.py